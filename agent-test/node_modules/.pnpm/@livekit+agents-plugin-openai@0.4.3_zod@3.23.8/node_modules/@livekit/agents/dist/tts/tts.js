import { AsyncIterableQueue } from '../utils.js';
/**
 * An instance of a text-to-speech adapter.
 *
 * @remarks
 * This class is abstract, and as such cannot be used directly. Instead, use a provider plugin that
 * exports its own child TTS class, which inherits this class's methods.
 */
export class TTS {
    #capabilities;
    #sampleRate;
    #numChannels;
    constructor(sampleRate, numChannels, capabilities) {
        this.#capabilities = capabilities;
        this.#sampleRate = sampleRate;
        this.#numChannels = numChannels;
    }
    /** Returns this TTS's capabilities */
    get capabilities() {
        return this.#capabilities;
    }
    /** Returns the sample rate of audio frames returned by this TTS */
    get sampleRate() {
        return this.#sampleRate;
    }
    /** Returns the channel count of audio frames returned by this TTS */
    get numChannels() {
        return this.#numChannels;
    }
}
/**
 * An instance of a text-to-speech stream, as an asynchronous iterable iterator.
 *
 * @example Looping through frames
 * ```ts
 * for await (const event of stream) {
 *   await source.captureFrame(event.frame);
 * }
 * ```
 *
 * @remarks
 * This class is abstract, and as such cannot be used directly. Instead, use a provider plugin that
 * exports its own child SynthesizeStream class, which inherits this class's methods.
 */
export class SynthesizeStream {
    static FLUSH_SENTINEL = Symbol('FLUSH_SENTINEL');
    static END_OF_STREAM = Symbol('END_OF_STREAM');
    input = new AsyncIterableQueue();
    queue = new AsyncIterableQueue();
    closed = false;
    /** Push a string of text to the TTS */
    pushText(text) {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.input.put(text);
    }
    /** Flush the TTS, causing it to process all pending text */
    flush() {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.input.put(SynthesizeStream.FLUSH_SENTINEL);
    }
    /** Mark the input as ended and forbid additional pushes */
    endInput() {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.input.close();
    }
    next() {
        return this.queue.next();
    }
    /** Close both the input and output of the TTS stream */
    close() {
        this.input.close();
        this.queue.close();
        this.closed = true;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
//# sourceMappingURL=tts.js.map