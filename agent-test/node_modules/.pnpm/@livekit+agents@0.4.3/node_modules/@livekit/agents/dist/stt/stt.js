import { AsyncIterableQueue } from '../utils.js';
/** Indicates start/middle/end of speech */
export var SpeechEventType;
(function (SpeechEventType) {
    /**
     * Indicate the start of speech.
     * If the STT doesn't support this event, this will be emitted at the same time
     * as the first INTERIM_TRANSCRIPT.
     */
    SpeechEventType[SpeechEventType["START_OF_SPEECH"] = 0] = "START_OF_SPEECH";
    /**
     * Interim transcript, useful for real-time transcription.
     */
    SpeechEventType[SpeechEventType["INTERIM_TRANSCRIPT"] = 1] = "INTERIM_TRANSCRIPT";
    /**
     * Final transcript, emitted when the STT is confident enough that a certain
     * portion of the speech will not change.
     */
    SpeechEventType[SpeechEventType["FINAL_TRANSCRIPT"] = 2] = "FINAL_TRANSCRIPT";
    /**
     * Indicate the end of speech, emitted when the user stops speaking.
     * The first alternative is a combination of all the previous FINAL_TRANSCRIPT events.
     */
    SpeechEventType[SpeechEventType["END_OF_SPEECH"] = 3] = "END_OF_SPEECH";
})(SpeechEventType || (SpeechEventType = {}));
/**
 * An instance of a speech-to-text adapter.
 *
 * @remarks
 * This class is abstract, and as such cannot be used directly. Instead, use a provider plugin that
 * exports its own child STT class, which inherits this class's methods.
 */
export class STT {
    #capabilities;
    constructor(capabilities) {
        this.#capabilities = capabilities;
    }
    /** Returns this STT's capabilities */
    get capabilities() {
        return this.#capabilities;
    }
}
/**
 * An instance of a speech-to-text stream, as an asynchronous iterable iterator.
 *
 * @example Looping through frames
 * ```ts
 * for await (const event of stream) {
 *   if (event.type === SpeechEventType.FINAL_TRANSCRIPT) {
 *     console.log(event.alternatives[0].text)
 *   }
 * }
 * ```
 *
 * @remarks
 * This class is abstract, and as such cannot be used directly. Instead, use a provider plugin that
 * exports its own child SpeechStream class, which inherits this class's methods.
 */
export class SpeechStream {
    static FLUSH_SENTINEL = Symbol('FLUSH_SENTINEL');
    input = new AsyncIterableQueue();
    queue = new AsyncIterableQueue();
    closed = false;
    /** Push an audio frame to the STT */
    pushFrame(frame) {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.input.put(frame);
    }
    /** Flush the STT, causing it to process all pending text */
    flush() {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.input.put(SpeechStream.FLUSH_SENTINEL);
    }
    /** Mark the input as ended and forbid additional pushes */
    endInput() {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.input.close();
    }
    next() {
        return this.queue.next();
    }
    /** Close both the input and output of the STT stream */
    close() {
        this.input.close();
        this.queue.close();
        this.closed = true;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
//# sourceMappingURL=stt.js.map