import { log } from './log.js';
export class BasicTranscriptionForwarder {
    #room;
    #participantIdentity;
    #trackSid;
    #currentText = '';
    #totalAudioDuration = 0;
    #currentPlayoutTime = 0;
    #DEFAULT_CHARS_PER_SECOND = 16;
    #charsPerSecond = this.#DEFAULT_CHARS_PER_SECOND;
    #messageId;
    #isRunning = false;
    #logger = log();
    currentCharacterIndex = 0;
    constructor(room, participantIdentity, trackSid, messageId) {
        this.#room = room;
        this.#participantIdentity = participantIdentity;
        this.#trackSid = trackSid;
        this.#messageId = messageId;
    }
    start() {
        if (!this.#isRunning) {
            this.#isRunning = true;
            this.#startPublishingLoop().catch((error) => {
                this.#logger.error('Error in publishing loop:', error);
                this.#isRunning = false;
            });
        }
    }
    pushAudio(frame) {
        this.#totalAudioDuration += frame.samplesPerChannel / frame.sampleRate;
    }
    pushText(text) {
        this.#currentText += text;
    }
    #textIsComplete = false;
    #audioIsComplete = false;
    markTextComplete() {
        this.#textIsComplete = true;
        this.#adjustTimingIfBothFinished();
    }
    markAudioComplete() {
        this.#audioIsComplete = true;
        this.#adjustTimingIfBothFinished();
    }
    #adjustTimingIfBothFinished() {
        if (this.#textIsComplete && this.#audioIsComplete) {
            const actualDuration = this.#totalAudioDuration;
            if (actualDuration > 0 && this.#currentText.length > 0) {
                this.#charsPerSecond = this.#currentText.length / actualDuration;
            }
        }
    }
    #computeSleepInterval() {
        return Math.min(Math.max(1 / this.#charsPerSecond, 0.0625), 0.5);
    }
    async #startPublishingLoop() {
        this.#isRunning = true;
        let sleepInterval = this.#computeSleepInterval();
        let isComplete = false;
        while (this.#isRunning && !isComplete) {
            this.#currentPlayoutTime += sleepInterval;
            this.currentCharacterIndex = Math.floor(this.#currentPlayoutTime * this.#charsPerSecond);
            isComplete = this.#textIsComplete && this.currentCharacterIndex >= this.#currentText.length;
            await this.#publishTranscription(false);
            if (this.#isRunning && !isComplete) {
                sleepInterval = this.#computeSleepInterval();
                await new Promise((resolve) => setTimeout(resolve, sleepInterval * 1000));
            }
        }
        if (this.#isRunning) {
            this.close(false);
        }
    }
    async #publishTranscription(final) {
        const textToPublish = this.#currentText.slice(0, this.currentCharacterIndex);
        await this.#room.localParticipant?.publishTranscription({
            participantIdentity: this.#participantIdentity,
            trackSid: this.#trackSid,
            segments: [
                {
                    text: textToPublish,
                    final: final,
                    id: this.#messageId,
                    startTime: BigInt(0),
                    endTime: BigInt(0),
                    language: '',
                },
            ],
        });
    }
    async close(interrupt) {
        this.#isRunning = false;
        // Publish whatever we had as final
        if (!interrupt) {
            this.currentCharacterIndex = this.#currentText.length;
        }
        await this.#publishTranscription(true);
    }
}
//# sourceMappingURL=transcription.js.map