import { AsyncIterableQueue } from './utils.js';
export var VADEventType;
(function (VADEventType) {
    VADEventType[VADEventType["START_OF_SPEECH"] = 0] = "START_OF_SPEECH";
    VADEventType[VADEventType["INFERENCE_DONE"] = 1] = "INFERENCE_DONE";
    VADEventType[VADEventType["END_OF_SPEECH"] = 2] = "END_OF_SPEECH";
})(VADEventType || (VADEventType = {}));
export class VAD {
    #capabilities;
    constructor(capabilities) {
        this.#capabilities = capabilities;
    }
    get capabilities() {
        return this.#capabilities;
    }
}
export class VADStream {
    static FLUSH_SENTINEL = Symbol('FLUSH_SENTINEL');
    input = new AsyncIterableQueue();
    queue = new AsyncIterableQueue();
    closed = false;
    pushFrame(frame) {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.input.put(frame);
    }
    flush() {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.input.put(VADStream.FLUSH_SENTINEL);
    }
    endInput() {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.input.close();
    }
    next() {
        return this.queue.next();
    }
    close() {
        this.input.close();
        this.queue.close();
        this.closed = true;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
//# sourceMappingURL=vad.js.map