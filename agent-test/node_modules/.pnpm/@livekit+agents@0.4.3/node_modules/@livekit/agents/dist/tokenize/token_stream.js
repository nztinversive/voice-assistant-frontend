// SPDX-FileCopyrightText: 2024 LiveKit, Inc.
//
// SPDX-License-Identifier: Apache-2.0
import { randomUUID } from 'node:crypto';
import { AsyncIterableQueue } from '../utils.js';
import { SentenceStream, WordStream } from './tokenizer.js';
export class BufferedTokenStream {
    queue = new AsyncIterableQueue();
    closed = false;
    #func;
    #minTokenLength;
    #minContextLength;
    #bufTokens = [];
    #inBuf = '';
    #outBuf = '';
    #currentSegmentId;
    constructor(func, minTokenLength, minContextLength) {
        this.#func = func;
        this.#minTokenLength = minTokenLength;
        this.#minContextLength = minContextLength;
        this.#currentSegmentId = randomUUID();
    }
    /** Push a string of text into the token stream */
    pushText(text) {
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.#inBuf += text;
        if (this.#inBuf.length < this.#minContextLength)
            return;
        while (true) {
            const tokens = this.#func(this.#inBuf);
            if (tokens.length === 0)
                break;
            if (this.#outBuf)
                this.#outBuf += ' ';
            const tok = tokens.shift();
            let tokText = tok;
            if (tok.length > 1 && typeof tok[1] === 'number') {
                tokText = tok[0];
            }
            this.#outBuf += tokText;
            if (this.#outBuf.length >= this.#minTokenLength) {
                this.queue.put({ token: this.#outBuf, segmentId: this.#currentSegmentId });
                this.#outBuf = '';
            }
            if (typeof tok !== 'string') {
                this.#inBuf = this.#inBuf.slice(tok[2]);
            }
            else {
                this.#inBuf = this.#inBuf
                    .slice(Math.max(0, this.#inBuf.indexOf(tok)) + tok.length)
                    .trimStart();
            }
        }
    }
    /** Flush the stream, causing it to process all pending text */
    flush() {
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        if (this.#inBuf || this.#outBuf) {
            const tokens = this.#func(this.#inBuf);
            if (tokens) {
                if (this.#outBuf)
                    this.#outBuf += ' ';
                if (typeof tokens[0] !== 'string') {
                    this.#outBuf += tokens.map((tok) => tok[0]).join(' ');
                }
                else {
                    this.#outBuf += tokens.join(' ');
                }
            }
            if (this.#outBuf) {
                this.queue.put({ token: this.#outBuf, segmentId: this.#currentSegmentId });
            }
            this.#currentSegmentId = randomUUID();
        }
        this.#inBuf = '';
        this.#outBuf = '';
    }
    /** Mark the input as ended and forbid additional pushes */
    endInput() {
        if (this.closed) {
            throw new Error('Stream is closed');
        }
        this.flush();
        this.closed = true;
    }
    next() {
        return this.queue.next();
    }
    /** Close both the input and output of the token stream */
    close() {
        this.queue.close();
        this.closed = true;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
export class BufferedSentenceStream extends SentenceStream {
    #stream;
    constructor(func, minTokenLength, minContextLength) {
        super();
        this.#stream = new BufferedTokenStream(func, minTokenLength, minContextLength);
    }
    pushText(text) {
        this.#stream.pushText(text);
    }
    close() {
        super.close();
        this.#stream.close();
    }
    next() {
        return this.#stream.next();
    }
}
export class BufferedWordStream extends WordStream {
    #stream;
    constructor(func, minTokenLength, minContextLength) {
        super();
        this.#stream = new BufferedTokenStream(func, minTokenLength, minContextLength);
    }
    pushText(text) {
        this.#stream.pushText(text);
    }
    close() {
        super.close();
        this.#stream.close();
    }
    next() {
        return this.#stream.next();
    }
}
//# sourceMappingURL=token_stream.js.map