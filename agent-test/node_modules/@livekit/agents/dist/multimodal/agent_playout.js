import { EventEmitter } from 'node:events';
import { AudioByteStream } from '../audio.js';
import { CancellablePromise, Future, gracefullyCancel } from '../utils.js';
export const proto = {};
export class PlayoutHandle extends EventEmitter {
    #audioSource;
    #sampleRate;
    #itemId;
    #contentIndex;
    /** @internal */
    transcriptionFwd;
    /** @internal */
    doneFut;
    /** @internal */
    intFut;
    /** @internal */
    #interrupted;
    /** @internal */
    pushedDuration;
    /** @internal */
    totalPlayedTime; // Set when playout is done
    constructor(audioSource, sampleRate, itemId, contentIndex, transcriptionFwd) {
        super();
        this.#audioSource = audioSource;
        this.#sampleRate = sampleRate;
        this.#itemId = itemId;
        this.#contentIndex = contentIndex;
        this.transcriptionFwd = transcriptionFwd;
        this.doneFut = new Future();
        this.intFut = new Future();
        this.#interrupted = false;
        this.pushedDuration = 0;
        this.totalPlayedTime = undefined;
    }
    get itemId() {
        return this.#itemId;
    }
    get audioSamples() {
        if (this.totalPlayedTime !== undefined) {
            return Math.floor(this.totalPlayedTime * this.#sampleRate);
        }
        return Math.floor((this.pushedDuration - this.#audioSource.queuedDuration) * (this.#sampleRate / 1000));
    }
    get textChars() {
        return this.transcriptionFwd.currentCharacterIndex;
    }
    get contentIndex() {
        return this.#contentIndex;
    }
    get interrupted() {
        return this.#interrupted;
    }
    get done() {
        return this.doneFut.done || this.#interrupted;
    }
    interrupt() {
        if (this.doneFut.done)
            return;
        this.intFut.resolve();
        this.#interrupted = true;
    }
}
export class AgentPlayout extends EventEmitter {
    #audioSource;
    #playoutTask;
    #sampleRate;
    #numChannels;
    #inFrameSize;
    #outFrameSize;
    constructor(audioSource, sampleRate, numChannels, inFrameSize, outFrameSize) {
        super();
        this.#audioSource = audioSource;
        this.#playoutTask = null;
        this.#sampleRate = sampleRate;
        this.#numChannels = numChannels;
        this.#inFrameSize = inFrameSize;
        this.#outFrameSize = outFrameSize;
    }
    play(itemId, contentIndex, transcriptionFwd, textStream, audioStream) {
        const handle = new PlayoutHandle(this.#audioSource, this.#sampleRate, itemId, contentIndex, transcriptionFwd);
        this.#playoutTask = this.#makePlayoutTask(this.#playoutTask, handle, textStream, audioStream);
        return handle;
    }
    #makePlayoutTask(oldTask, handle, textStream, audioStream) {
        return new CancellablePromise((resolve, reject, onCancel) => {
            let cancelled = false;
            onCancel(() => {
                cancelled = true;
            });
            (async () => {
                try {
                    if (oldTask) {
                        await gracefullyCancel(oldTask);
                    }
                    let firstFrame = true;
                    const readText = () => new CancellablePromise((resolveText, rejectText, onCancelText) => {
                        let cancelledText = false;
                        onCancelText(() => {
                            cancelledText = true;
                        });
                        (async () => {
                            try {
                                for await (const text of textStream) {
                                    if (cancelledText || cancelled) {
                                        break;
                                    }
                                    handle.transcriptionFwd.pushText(text);
                                }
                                resolveText();
                            }
                            catch (error) {
                                rejectText(error);
                            }
                        })();
                    });
                    const capture = () => new CancellablePromise((resolveCapture, rejectCapture, onCancelCapture) => {
                        let cancelledCapture = false;
                        onCancelCapture(() => {
                            cancelledCapture = true;
                        });
                        (async () => {
                            try {
                                const samplesPerChannel = this.#outFrameSize;
                                const bstream = new AudioByteStream(this.#sampleRate, this.#numChannels, samplesPerChannel);
                                for await (const frame of audioStream) {
                                    if (cancelledCapture || cancelled) {
                                        break;
                                    }
                                    if (firstFrame) {
                                        handle.transcriptionFwd.start();
                                        this.emit('playout_started');
                                        firstFrame = false;
                                    }
                                    handle.transcriptionFwd.pushAudio(frame);
                                    for (const f of bstream.write(frame.data.buffer)) {
                                        handle.pushedDuration += (f.samplesPerChannel / f.sampleRate) * 1000;
                                        await this.#audioSource.captureFrame(f);
                                    }
                                }
                                if (!cancelledCapture && !cancelled) {
                                    for (const f of bstream.flush()) {
                                        handle.pushedDuration += (f.samplesPerChannel / f.sampleRate) * 1000;
                                        await this.#audioSource.captureFrame(f);
                                    }
                                    handle.transcriptionFwd.markAudioComplete();
                                    await this.#audioSource.waitForPlayout();
                                }
                                resolveCapture();
                            }
                            catch (error) {
                                rejectCapture(error);
                            }
                        })();
                    });
                    const readTextTask = readText();
                    const captureTask = capture();
                    try {
                        await Promise.race([captureTask, handle.intFut.await]);
                    }
                    finally {
                        if (!captureTask.isCancelled) {
                            await gracefullyCancel(captureTask);
                        }
                        handle.totalPlayedTime = handle.pushedDuration - this.#audioSource.queuedDuration;
                        if (handle.interrupted || captureTask.error) {
                            this.#audioSource.clearQueue(); // make sure to remove any queued frames
                        }
                        if (!readTextTask.isCancelled) {
                            await gracefullyCancel(readTextTask);
                        }
                        if (!firstFrame) {
                            if (!handle.interrupted) {
                                handle.transcriptionFwd.markTextComplete();
                            }
                            this.emit('playout_stopped', handle.interrupted);
                        }
                        handle.doneFut.resolve();
                        await handle.transcriptionFwd.close(handle.interrupted);
                    }
                    resolve();
                }
                catch (error) {
                    reject(error);
                }
            })();
        });
    }
}
//# sourceMappingURL=agent_playout.js.map