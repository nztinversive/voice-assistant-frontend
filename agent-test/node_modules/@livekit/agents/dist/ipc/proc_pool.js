// SPDX-FileCopyrightText: 2024 LiveKit, Inc.
//
// SPDX-License-Identifier: Apache-2.0
import { MultiMutex, Mutex } from '@livekit/mutex';
import { Queue } from '../utils.js';
import { ProcJobExecutor } from './proc_job_executor.js';
export class ProcPool {
    agent;
    initializeTimeout;
    closeTimeout;
    executors = [];
    tasks = [];
    started = false;
    closed = false;
    controller = new AbortController();
    initMutex = new Mutex();
    procMutex;
    procUnlock;
    warmedProcQueue = new Queue();
    constructor(agent, numIdleProcesses, initializeTimeout, closeTimeout) {
        this.agent = agent;
        if (numIdleProcesses > 0) {
            this.procMutex = new MultiMutex(numIdleProcesses);
        }
        this.initializeTimeout = initializeTimeout;
        this.closeTimeout = closeTimeout;
    }
    get processes() {
        return this.executors;
    }
    getByJobId(id) {
        return this.executors.find((x) => x.runningJob && x.runningJob.job.id === id) || null;
    }
    async launchJob(info) {
        let proc;
        if (this.procMutex) {
            proc = await this.warmedProcQueue.get();
            if (this.procUnlock) {
                this.procUnlock();
                this.procUnlock = undefined;
            }
        }
        else {
            proc = new ProcJobExecutor(this.agent, this.initializeTimeout, this.closeTimeout);
            this.executors.push(proc);
            await proc.start();
            await proc.initialize();
        }
        await proc.launchJob(info);
    }
    async procWatchTask() {
        const proc = new ProcJobExecutor(this.agent, this.initializeTimeout, this.closeTimeout);
        try {
            this.executors.push(proc);
            const unlock = await this.initMutex.lock();
            if (this.closed) {
                return;
            }
            await proc.start();
            try {
                await proc.initialize();
                await this.warmedProcQueue.put(proc);
            }
            catch {
                if (this.procUnlock) {
                    this.procUnlock();
                    this.procUnlock = undefined;
                }
            }
            unlock();
            await proc.join();
        }
        finally {
            this.executors.splice(this.executors.indexOf(proc));
        }
    }
    start() {
        if (this.started) {
            return;
        }
        this.started = true;
        this.run(this.controller.signal);
    }
    async run(signal) {
        if (this.procMutex) {
            while (!signal.aborted) {
                this.procUnlock = await this.procMutex.lock();
                const task = this.procWatchTask();
                this.tasks.push(task);
                task.finally(() => this.tasks.splice(this.tasks.indexOf(task)));
            }
        }
    }
    async close() {
        if (!this.started) {
            return;
        }
        this.closed = true;
        this.controller.abort();
        this.warmedProcQueue.items.forEach((e) => e.close());
        this.executors.forEach((e) => e.close());
        await Promise.allSettled(this.tasks);
    }
}
//# sourceMappingURL=proc_pool.js.map