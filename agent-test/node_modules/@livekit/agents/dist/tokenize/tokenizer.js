// SPDX-FileCopyrightText: 2024 LiveKit, Inc.
//
// SPDX-License-Identifier: Apache-2.0
import { AsyncIterableQueue } from '../utils.js';
// prettier-ignore
export const PUNCTUATIONS = [
    '!', '"', '#', '$', '%', '&', "'", '(', ')', '*', '+', ',', '-', '.', '/', ':', ';', '<', '=',
    '>', '?', '@', '[', '\\', ']', '^', '_', '`', '{', '|', '}', '~', '±', '—', '‘', '’', '“', '”',
    '…',
];
export class SentenceTokenizer {
}
export class SentenceStream {
    static FLUSH_SENTINEL = Symbol('FLUSH_SENTINEL');
    input = new AsyncIterableQueue();
    queue = new AsyncIterableQueue();
    #closed = false;
    get closed() {
        return this.#closed;
    }
    /** Push a string of text to the tokenizer */
    pushText(text) {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.#closed) {
            throw new Error('Stream is closed');
        }
        this.input.put(text);
    }
    /** Flush the tokenizer, causing it to process all pending text */
    flush() {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.#closed) {
            throw new Error('Stream is closed');
        }
        this.input.put(SentenceStream.FLUSH_SENTINEL);
    }
    /** Mark the input as ended and forbid additional pushes */
    endInput() {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.#closed) {
            throw new Error('Stream is closed');
        }
        this.input.close();
    }
    next() {
        return this.queue.next();
    }
    /** Close both the input and output of the tokenizer stream */
    close() {
        this.input.close();
        this.queue.close();
        this.#closed = true;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
export class WordTokenizer {
}
export class WordStream {
    static FLUSH_SENTINEL = Symbol('FLUSH_SENTINEL');
    input = new AsyncIterableQueue();
    queue = new AsyncIterableQueue();
    #closed = false;
    get closed() {
        return this.#closed;
    }
    /** Push a string of text to the tokenizer */
    pushText(text) {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.#closed) {
            throw new Error('Stream is closed');
        }
        this.input.put(text);
    }
    /** Flush the tokenizer, causing it to process all pending text */
    flush() {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.#closed) {
            throw new Error('Stream is closed');
        }
        this.input.put(WordStream.FLUSH_SENTINEL);
    }
    /** Mark the input as ended and forbid additional pushes */
    endInput() {
        if (this.input.closed) {
            throw new Error('Input is closed');
        }
        if (this.#closed) {
            throw new Error('Stream is closed');
        }
        this.input.close();
    }
    next() {
        return this.queue.next();
    }
    /** Close both the input and output of the tokenizer stream */
    close() {
        this.input.close();
        this.queue.close();
        this.#closed = true;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
//# sourceMappingURL=tokenizer.js.map