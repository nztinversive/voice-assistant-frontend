import { log } from '../log.js';
import { SynthesizeStream } from '../tts/index.js';
import { AsyncIterableQueue, CancellablePromise, Future, gracefullyCancel } from '../utils.js';
export class SynthesisHandle {
    static FLUSH_SENTINEL = Symbol('FLUSH_SENTINEL');
    #speechId;
    ttsSource;
    #agentPlayout;
    tts;
    queue = new AsyncIterableQueue();
    #playHandle;
    intFut = new Future();
    #logger = log();
    constructor(speechId, ttsSource, agentPlayout, tts) {
        this.#speechId = speechId;
        this.ttsSource = ttsSource;
        this.#agentPlayout = agentPlayout;
        this.tts = tts;
    }
    get speechId() {
        return this.#speechId;
    }
    get validated() {
        return !!this.#playHandle;
    }
    get interrupted() {
        return this.intFut.done;
    }
    get playHandle() {
        return this.#playHandle;
    }
    /** Validate the speech for playout. */
    play() {
        if (this.interrupted) {
            throw new Error('synthesis was interrupted');
        }
        this.#playHandle = this.#agentPlayout.play(this.#speechId, this.queue);
        return this.#playHandle;
    }
    /** Interrupt the speech. */
    interrupt() {
        if (this.interrupted) {
            return;
        }
        this.#logger.child({ speechId: this.#speechId }).debug('interrupting synthesis/playout');
        this.#playHandle?.interrupt();
        this.intFut.resolve();
    }
}
export class AgentOutput {
    #agentPlayout;
    #tts;
    #tasks = [];
    constructor(agentPlayout, tts) {
        this.#agentPlayout = agentPlayout;
        this.#tts = tts;
    }
    get playout() {
        return this.#agentPlayout;
    }
    async close() {
        this.#tasks.forEach((task) => task.cancel());
        await Promise.all(this.#tasks);
    }
    synthesize(speechId, ttsSource) {
        const handle = new SynthesisHandle(speechId, ttsSource, this.#agentPlayout, this.#tts);
        const task = this.#synthesize(handle);
        this.#tasks.push(task);
        task.finally(() => this.#tasks.splice(this.#tasks.indexOf(task)));
        return handle;
    }
    #synthesize(handle) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        return new CancellablePromise(async (resolve, _, onCancel) => {
            const ttsSource = await handle.ttsSource;
            let task;
            if (typeof ttsSource === 'string') {
                task = stringSynthesisTask(ttsSource, handle);
            }
            else {
                task = streamSynthesisTask(ttsSource, handle);
            }
            onCancel(() => {
                gracefullyCancel(task);
            });
            try {
                await Promise.any([task, handle.intFut.await]);
            }
            finally {
                if (handle.intFut.done) {
                    gracefullyCancel(task);
                }
            }
            resolve();
        });
    }
}
const stringSynthesisTask = (text, handle) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return new CancellablePromise(async (resolve, _, onCancel) => {
        let cancelled = false;
        onCancel(() => {
            cancelled = true;
        });
        const ttsStream = handle.tts.stream();
        ttsStream.pushText(text);
        ttsStream.flush();
        ttsStream.endInput();
        for await (const audio of ttsStream) {
            if (cancelled || audio === SynthesizeStream.END_OF_STREAM)
                break;
            handle.queue.put(audio.frame);
        }
        handle.queue.put(SynthesisHandle.FLUSH_SENTINEL);
        resolve();
    });
};
const streamSynthesisTask = (stream, handle) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return new CancellablePromise(async (resolve, _, onCancel) => {
        let cancelled = false;
        onCancel(() => {
            cancelled = true;
        });
        const ttsStream = handle.tts.stream();
        const readGeneratedAudio = async () => {
            let started = false;
            for await (const audio of ttsStream) {
                if (cancelled)
                    break;
                if (audio === SynthesizeStream.END_OF_STREAM) {
                    if (started) {
                        break;
                    }
                    else {
                        continue;
                    }
                }
                handle.queue.put(audio.frame);
                started = true;
            }
            handle.queue.put(SynthesisHandle.FLUSH_SENTINEL);
        };
        readGeneratedAudio();
        for await (const text of stream) {
            if (cancelled)
                break;
            ttsStream.pushText(text);
        }
        ttsStream.flush();
        ttsStream.endInput();
        resolve();
    });
};
//# sourceMappingURL=agent_output.js.map