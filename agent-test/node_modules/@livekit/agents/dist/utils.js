var _a;
import { AudioFrame, TrackSource } from '@livekit/rtc-node';
import { EventEmitter, once } from 'node:events';
/**
 * Merge one or more {@link AudioFrame}s into a single one.
 *
 * @param buffer Either an {@link AudioFrame} or a list thereof
 * @throws
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError
 * | TypeError} if sample rate or channel count are mismatched
 */
export const mergeFrames = (buffer) => {
    if (Array.isArray(buffer)) {
        buffer = buffer;
        if (buffer.length == 0) {
            throw new TypeError('buffer is empty');
        }
        const sampleRate = buffer[0].sampleRate;
        const channels = buffer[0].channels;
        let samplesPerChannel = 0;
        let data = new Int16Array();
        for (const frame of buffer) {
            if (frame.sampleRate !== sampleRate) {
                throw new TypeError('sample rate mismatch');
            }
            if (frame.channels !== channels) {
                throw new TypeError('channel count mismatch');
            }
            data = new Int16Array([...data, ...frame.data]);
            samplesPerChannel += frame.samplesPerChannel;
        }
        return new AudioFrame(data, sampleRate, channels, samplesPerChannel);
    }
    return buffer;
};
export const findMicroTrackId = (room, identity) => {
    let p = room.remoteParticipants.get(identity);
    if (identity === room.localParticipant?.identity) {
        p = room.localParticipant;
    }
    if (!p) {
        throw new Error(`participant ${identity} not found`);
    }
    // find first micro track
    let trackId;
    p.trackPublications.forEach((track) => {
        if (track.source === TrackSource.SOURCE_MICROPHONE) {
            trackId = track.sid;
            return;
        }
    });
    if (!trackId) {
        throw new Error(`participant ${identity} does not have a microphone track`);
    }
    return trackId;
};
/** @internal */
export class Queue {
    /** @internal */
    items = [];
    #limit;
    #events = new EventEmitter();
    constructor(limit) {
        this.#limit = limit;
    }
    async get() {
        if (this.items.length === 0) {
            await once(this.#events, 'put');
        }
        const item = this.items.shift();
        this.#events.emit('get');
        return item;
    }
    async put(item) {
        if (this.#limit && this.items.length >= this.#limit) {
            await once(this.#events, 'get');
        }
        this.items.push(item);
        this.#events.emit('put');
    }
}
/** @internal */
export class Future {
    #await;
    #resolvePromise;
    #rejectPromise;
    #done = false;
    constructor() {
        this.#await = new Promise((resolve, reject) => {
            this.#resolvePromise = resolve;
            this.#rejectPromise = reject;
        });
    }
    get await() {
        return this.#await;
    }
    get done() {
        return this.#done;
    }
    resolve() {
        this.#done = true;
        this.#resolvePromise();
    }
    reject(error) {
        this.#done = true;
        this.#rejectPromise(error);
    }
}
/** @internal */
export class CancellablePromise {
    #promise;
    #cancelFn;
    #isCancelled = false;
    #error = null;
    constructor(executor) {
        let cancel;
        this.#promise = new Promise((resolve, reject) => {
            executor(resolve, (reason) => {
                this.#error = reason instanceof Error ? reason : new Error(String(reason));
                reject(reason);
            }, (cancelFn) => {
                cancel = () => {
                    this.#isCancelled = true;
                    cancelFn();
                };
            });
        });
        this.#cancelFn = cancel;
    }
    get isCancelled() {
        return this.#isCancelled;
    }
    get error() {
        return this.#error;
    }
    then(onfulfilled, onrejected) {
        return this.#promise.then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.#promise.catch(onrejected);
    }
    finally(onfinally) {
        return this.#promise.finally(onfinally);
    }
    cancel() {
        this.#cancelFn();
    }
    static from(promise) {
        return new CancellablePromise((resolve, reject) => {
            promise.then(resolve).catch(reject);
        });
    }
}
/** @internal */
export async function gracefullyCancel(promise) {
    if (!promise.isCancelled) {
        promise.cancel();
    }
    try {
        await promise;
    }
    catch (error) {
        // Ignore the error, as it's expected due to cancellation
    }
}
/** @internal */
export class AsyncIterableQueue {
    static CLOSE_SENTINEL = Symbol('CLOSE_SENTINEL');
    #queue = new Queue();
    #closed = false;
    get closed() {
        return this.#closed;
    }
    put(item) {
        if (this.#closed) {
            throw new Error('Queue is closed');
        }
        this.#queue.put(item);
    }
    close() {
        this.#closed = true;
        this.#queue.put(_a.CLOSE_SENTINEL);
    }
    async next() {
        if (this.#closed && this.#queue.items.length === 0) {
            return { value: undefined, done: true };
        }
        const item = await this.#queue.get();
        if (item === _a.CLOSE_SENTINEL && this.#closed) {
            return { value: undefined, done: true };
        }
        return { value: item, done: false };
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
_a = AsyncIterableQueue;
/** @internal */
export class ExpFilter {
    #alpha;
    #max;
    #filtered = undefined;
    constructor(alpha, max) {
        this.#alpha = alpha;
        this.#max = max;
    }
    reset(alpha) {
        if (alpha) {
            this.#alpha = alpha;
        }
        this.#filtered = undefined;
    }
    apply(exp, sample) {
        if (this.#filtered) {
            const a = this.#alpha ** exp;
            this.#filtered = a * this.#filtered + (1 - a) * sample;
        }
        else {
            this.#filtered = sample;
        }
        if (this.#max && this.#filtered > this.#max) {
            this.#filtered = this.#max;
        }
        return this.#filtered;
    }
    get filtered() {
        return this.#filtered;
    }
    set alpha(alpha) {
        this.#alpha = alpha;
    }
}
/** @internal */
export class AudioEnergyFilter {
    #cooldownSeconds;
    #cooldown;
    constructor(cooldownSeconds = 1) {
        this.#cooldownSeconds = cooldownSeconds;
        this.#cooldown = cooldownSeconds;
    }
    pushFrame(frame) {
        const arr = Float32Array.from(frame.data, (x) => x / 32768);
        const rms = (arr.map((x) => x ** 2).reduce((acc, x) => acc + x) / arr.length) ** 0.5;
        if (rms > 0.004) {
            this.#cooldown = this.#cooldownSeconds;
            return true;
        }
        const durationSeconds = frame.samplesPerChannel / frame.sampleRate;
        this.#cooldown -= durationSeconds;
        if (this.#cooldown > 0) {
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=utils.js.map